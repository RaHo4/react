{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.liftAction = liftAction;\nexports.liftReducerWith = liftReducerWith;\nexports.unliftState = unliftState;\nexports.unliftStore = unliftStore;\nexports[\"default\"] = instrument;\nexports.INIT_ACTION = exports.ActionCreators = exports.ActionTypes = void 0;\nvar _difference = _interopRequireDefault(require(\"lodash/difference\"));\nvar _union = _interopRequireDefault(require(\"lodash/union\"));\nvar _isPlainObject = _interopRequireDefault(require(\"lodash/isPlainObject\"));\nvar _symbolObservable = _interopRequireDefault(require(\"symbol-observable\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nvar ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING'\n};\nexports.ActionTypes = ActionTypes;\nvar isChrome = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer');\nvar isChromeOrNode = isChrome || typeof process !== 'undefined' && process.release && process.release.name === 'node';\n\n/**\n * Action creators to change the History state.\n */\nvar ActionCreators = {\n  performAction: function performAction(action, trace, traceLimit,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  toExcludeFromTrace) {\n    if (!(0, _isPlainObject[\"default\"])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n    var stack;\n    if (trace) {\n      var extraFrames = 0;\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        var error = Error();\n        var prevStackTraceLimit;\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (traceLimit && Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n        if (extraFrames || typeof Error.stackTraceLimit !== 'number' || traceLimit && Error.stackTraceLimit > traceLimit) {\n          if (stack != null) {\n            var frames = stack.split('\\n');\n            if (traceLimit && frames.length > traceLimit) {\n              stack = frames.slice(0, traceLimit + extraFrames + (frames[0].startsWith('Error') ? 1 : 0)).join('\\n');\n            }\n          }\n        }\n      }\n    }\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action: action,\n      timestamp: Date.now(),\n      stack: stack\n    };\n  },\n  reset: function reset() {\n    return {\n      type: ActionTypes.RESET,\n      timestamp: Date.now()\n    };\n  },\n  rollback: function rollback() {\n    return {\n      type: ActionTypes.ROLLBACK,\n      timestamp: Date.now()\n    };\n  },\n  commit: function commit() {\n    return {\n      type: ActionTypes.COMMIT,\n      timestamp: Date.now()\n    };\n  },\n  sweep: function sweep() {\n    return {\n      type: ActionTypes.SWEEP\n    };\n  },\n  toggleAction: function toggleAction(id) {\n    return {\n      type: ActionTypes.TOGGLE_ACTION,\n      id: id\n    };\n  },\n  setActionsActive: function setActionsActive(start, end) {\n    var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return {\n      type: ActionTypes.SET_ACTIONS_ACTIVE,\n      start: start,\n      end: end,\n      active: active\n    };\n  },\n  reorderAction: function reorderAction(actionId, beforeActionId) {\n    return {\n      type: ActionTypes.REORDER_ACTION,\n      actionId: actionId,\n      beforeActionId: beforeActionId\n    };\n  },\n  jumpToState: function jumpToState(index) {\n    return {\n      type: ActionTypes.JUMP_TO_STATE,\n      index: index\n    };\n  },\n  jumpToAction: function jumpToAction(actionId) {\n    return {\n      type: ActionTypes.JUMP_TO_ACTION,\n      actionId: actionId\n    };\n  },\n  importState: function importState(nextLiftedState, noRecompute) {\n    return {\n      type: ActionTypes.IMPORT_STATE,\n      nextLiftedState: nextLiftedState,\n      noRecompute: noRecompute\n    };\n  },\n  lockChanges: function lockChanges(status) {\n    return {\n      type: ActionTypes.LOCK_CHANGES,\n      status: status\n    };\n  },\n  pauseRecording: function pauseRecording(status) {\n    return {\n      type: ActionTypes.PAUSE_RECORDING,\n      status: status\n    };\n  }\n};\nexports.ActionCreators = ActionCreators;\nvar INIT_ACTION = {\n  type: '@@INIT'\n};\n/**\n * Computes the next entry with exceptions catching.\n */\n\nexports.INIT_ACTION = INIT_ACTION;\nfunction computeWithTryCatch(reducer, action, state) {\n  var nextState = state;\n  var nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(function () {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Computes the next entry in the log by applying an action.\n */\n\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\n  if (!shouldCatchErrors) {\n    return {\n      state: reducer(state, action)\n    };\n  }\n  return computeWithTryCatch(reducer, action, state);\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (var i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    var _actionId = stagedActionIds[i];\n    var _action = actionsById[_actionId].action;\n    var previousEntry = nextComputedStates[i - 1];\n    var previousState = previousEntry ? previousEntry.state : committedState;\n    var shouldSkip = skippedActionIds.indexOf(_actionId) > -1;\n    var entry = void 0;\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain'\n        };\n      } else {\n        entry = computeNextEntry(reducer, _action, previousState, shouldCatchErrors);\n      }\n    }\n    nextComputedStates.push(entry);\n  }\n  return nextComputedStates;\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\n\nfunction liftAction(action, trace, traceLimit,\n// eslint-disable-next-line @typescript-eslint/ban-types\ntoExcludeFromTrace) {\n  return ActionCreators.performAction(action, trace, traceLimit, toExcludeFromTrace);\n}\nfunction isArray(nextLiftedState) {\n  return Array.isArray(nextLiftedState);\n}\n\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\n  var initialLiftedState = {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false\n  };\n  /**\n   * Manages how the history actions modify the history state.\n   */\n\n  return function (liftedState, liftedAction) {\n    var _ref = liftedState || initialLiftedState,\n      monitorState = _ref.monitorState,\n      actionsById = _ref.actionsById,\n      nextActionId = _ref.nextActionId,\n      stagedActionIds = _ref.stagedActionIds,\n      skippedActionIds = _ref.skippedActionIds,\n      committedState = _ref.committedState,\n      currentStateIndex = _ref.currentStateIndex,\n      computedStates = _ref.computedStates,\n      isLocked = _ref.isLocked,\n      isPaused = _ref.isPaused;\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = _objectSpread({}, actionsById);\n    }\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      var excess = n;\n      var idsToDelete = stagedActionIds.slice(1, excess + 1);\n      for (var i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n      skippedActionIds = skippedActionIds.filter(function (id) {\n        return idsToDelete.indexOf(id) === -1;\n      });\n      stagedActionIds = [0].concat(_toConsumableArray(stagedActionIds.slice(excess + 1)));\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n    function computePausedAction(shouldInit) {\n      var computedState;\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(monitorState, liftedAction);\n      } else {\n        computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);\n      }\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState: monitorState,\n          actionsById: {\n            0: liftAction(INIT_ACTION)\n          },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked: isLocked,\n          isPaused: true\n        };\n      }\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [nextActionId]);\n        nextActionId++;\n      }\n      return {\n        monitorState: monitorState,\n        actionsById: _objectSpread(_objectSpread({}, actionsById), {}, _defineProperty({}, nextActionId - 1, liftAction({\n          type: options.pauseActionType\n        }))),\n        nextActionId: nextActionId,\n        stagedActionIds: stagedActionIds,\n        skippedActionIds: skippedActionIds,\n        committedState: committedState,\n        currentStateIndex: currentStateIndex,\n        computedStates: [].concat(_toConsumableArray(computedStates.slice(0, stagedActionIds.length - 1)), [computedState]),\n        isLocked: isLocked,\n        isPaused: true\n      };\n    } // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n\n    var minInvalidatedStateIndex = 0; // maxAge number can be changed dynamically\n\n    var maxAge = options.maxAge;\n    if (typeof maxAge === 'function') maxAge = maxAge(liftedAction, liftedState);\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates.length === 0 ? initialCommittedState : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      } // Recompute states on hot reload and init.\n\n      minInvalidatedStateIndex = 0;\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n        commitExcessActions(stagedActionIds.length - maxAge); // Avoid double computation.\n\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION:\n          {\n            if (isLocked) return liftedState || initialLiftedState;\n            if (isPaused) return computePausedAction(); // Auto-commit as new actions come in.\n\n            if (maxAge && stagedActionIds.length >= maxAge) {\n              commitExcessActions(stagedActionIds.length - maxAge + 1);\n            }\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n            var _actionId2 = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n\n            actionsById[_actionId2] = liftedAction;\n            stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [_actionId2]); // Optimization: we know that only the new action needs computing.\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n        case ActionTypes.RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.COMMIT:\n          {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var _actionId3 = liftedAction.id;\n            var index = skippedActionIds.indexOf(_actionId3);\n            if (index === -1) {\n              skippedActionIds = [_actionId3].concat(_toConsumableArray(skippedActionIds));\n            } else {\n              skippedActionIds = skippedActionIds.filter(function (id) {\n                return id !== _actionId3;\n              });\n            } // Optimization: we know history before this action hasn't changed\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(_actionId3);\n            break;\n          }\n        case ActionTypes.SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var start = liftedAction.start,\n              end = liftedAction.end,\n              active = liftedAction.active;\n            var actionIds = [];\n            for (var i = start; i < end; i++) {\n              actionIds.push(i);\n            }\n            if (active) {\n              skippedActionIds = (0, _difference[\"default\"])(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = (0, _union[\"default\"])(skippedActionIds, actionIds);\n            } // Optimization: we know history before this action hasn't changed\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n        case ActionTypes.JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            var _index = stagedActionIds.indexOf(liftedAction.actionId);\n            if (_index !== -1) currentStateIndex = _index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = (0, _difference[\"default\"])(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n        case ActionTypes.REORDER_ACTION:\n          {\n            // Recompute actions in a new order.\n            var _actionId4 = liftedAction.actionId;\n            var idx = stagedActionIds.indexOf(_actionId4); // do nothing in case the action is already removed or trying to move the first action\n\n            if (idx < 1) break;\n            var beforeActionId = liftedAction.beforeActionId;\n            var newIdx = stagedActionIds.indexOf(beforeActionId);\n            if (newIdx < 1) {\n              // move to the beginning or to the end\n              var count = stagedActionIds.length;\n              newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n            }\n            var diff = idx - newIdx;\n            if (diff > 0) {\n              // move left\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, newIdx)), [_actionId4], _toConsumableArray(stagedActionIds.slice(newIdx, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1)));\n              minInvalidatedStateIndex = newIdx;\n            } else if (diff < 0) {\n              // move right\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1, newIdx)), [_actionId4], _toConsumableArray(stagedActionIds.slice(newIdx)));\n              minInvalidatedStateIndex = idx;\n            }\n            break;\n          }\n        case ActionTypes.IMPORT_STATE:\n          {\n            if (isArray(liftedAction.nextLiftedState)) {\n              // recompute array of actions\n              actionsById = {\n                0: liftAction(INIT_ACTION)\n              };\n              nextActionId = 1;\n              stagedActionIds = [0];\n              skippedActionIds = [];\n              currentStateIndex = liftedAction.nextLiftedState.length;\n              computedStates = [];\n              committedState = liftedAction.preloadedState;\n              minInvalidatedStateIndex = 0; // iterate through actions\n\n              liftedAction.nextLiftedState.forEach(function (action) {\n                actionsById[nextActionId] = liftAction(action, options.trace || options.shouldIncludeCallstack);\n                stagedActionIds.push(nextActionId);\n                nextActionId++;\n              });\n            } else {\n              // Completely replace everything.\n              var _liftedAction$nextLif = liftedAction.nextLiftedState;\n              monitorState = _liftedAction$nextLif.monitorState;\n              actionsById = _liftedAction$nextLif.actionsById;\n              nextActionId = _liftedAction$nextLif.nextActionId;\n              stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n              skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n              committedState = _liftedAction$nextLif.committedState;\n              currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n              computedStates = _liftedAction$nextLif.computedStates;\n              if (liftedAction.noRecompute) {\n                minInvalidatedStateIndex = Infinity;\n              }\n            }\n            break;\n          }\n        case ActionTypes.LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n            if (isPaused) {\n              return computePausedAction(true);\n            } // Commit when unpausing\n\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n    }\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState: monitorState,\n      actionsById: actionsById,\n      nextActionId: nextActionId,\n      stagedActionIds: stagedActionIds,\n      skippedActionIds: skippedActionIds,\n      committedState: committedState,\n      currentStateIndex: currentStateIndex,\n      computedStates: computedStates,\n      isLocked: isLocked,\n      isPaused: isPaused\n    };\n  };\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\n\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n    currentStateIndex = liftedState.currentStateIndex;\n  var state = computedStates[currentStateIndex].state;\n  return state;\n}\n\n/**\n * Provides an app's view into the lifted store.\n */\nfunction unliftStore(liftedStore, liftReducer, options) {\n  var lastDefinedState;\n  var trace = options.trace || options.shouldIncludeCallstack;\n  var traceLimit = options.traceLimit || 10;\n  function getState() {\n    var state = unliftState(liftedStore.getState());\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n    return lastDefinedState;\n  }\n  function dispatch(action) {\n    liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch));\n    return action;\n  }\n  return _objectSpread(_objectSpread({}, liftedStore), {}, _defineProperty({\n    liftedStore: liftedStore,\n    dispatch: dispatch,\n    getState: getState,\n    replaceReducer: function replaceReducer(nextReducer) {\n      liftedStore.replaceReducer(liftReducer(nextReducer));\n    }\n  }, _symbolObservable[\"default\"], function () {\n    return _objectSpread(_objectSpread({}, liftedStore[_symbolObservable[\"default\"]]()), {}, _defineProperty({\n      subscribe: function subscribe(observer) {\n        if (_typeof(observer) !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n        observeState();\n        var unsubscribe = liftedStore.subscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _symbolObservable[\"default\"], function () {\n      return this;\n    }));\n  }));\n}\n\n/**\n * Redux instrumentation store enhancer.\n */\nfunction instrument() {\n  var monitorReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return null;\n  };\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');\n  }\n  return function (createStore) {\n    return function (reducer, initialState) {\n      function liftReducer(r) {\n        if (typeof r !== 'function') {\n          if (r && typeof r[\"default\"] === 'function') {\n            throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a \"default\" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');\n          }\n          throw new Error('Expected the reducer to be a function.');\n        }\n        return liftReducerWith(r, initialState, monitorReducer, options);\n      }\n      var liftedStore = createStore(liftReducer(reducer));\n      if (liftedStore.liftedStore) {\n        throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');\n      }\n      return unliftStore(liftedStore, liftReducer, options);\n    };\n  };\n}","map":{"version":3,"mappings":"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","names":["ActionTypes","PERFORM_ACTION","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","REORDER_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","isChrome","window","chrome","process","type","isChromeOrNode","release","name","ActionCreators","performAction","action","trace","traceLimit","toExcludeFromTrace","Error","stack","extraFrames","error","prevStackTraceLimit","captureStackTrace","stackTraceLimit","frames","split","length","slice","startsWith","join","timestamp","Date","now","reset","rollback","commit","sweep","toggleAction","id","setActionsActive","start","end","active","reorderAction","actionId","beforeActionId","jumpToState","index","jumpToAction","importState","nextLiftedState","noRecompute","lockChanges","status","pauseRecording","INIT_ACTION","computeWithTryCatch","reducer","state","nextState","nextError","err","toString","setTimeout","console","computeNextEntry","shouldCatchErrors","recomputeStates","computedStates","minInvalidatedStateIndex","committedState","actionsById","stagedActionIds","skippedActionIds","nextComputedStates","i","previousEntry","previousState","shouldSkip","indexOf","entry","push","liftAction","isArray","Array","liftReducerWith","initialCommittedState","monitorReducer","options","initialLiftedState","monitorState","undefined","nextActionId","currentStateIndex","isLocked","shouldStartLocked","isPaused","shouldRecordChanges","liftedState","liftedAction","commitExcessActions","n","excess","idsToDelete","filter","computePausedAction","shouldInit","computedState","pauseActionType","maxAge","test","shouldHotReload","Infinity","actionIds","Math","min","idx","newIdx","count","diff","preloadedState","forEach","shouldIncludeCallstack","unliftState","unliftStore","liftedStore","liftReducer","lastDefinedState","getState","dispatch","replaceReducer","nextReducer","$$observable","subscribe","observer","_typeof","TypeError","observeState","next","unsubscribe","instrument","createStore","initialState","r"],"sources":["C:\\study\\курсы\\react\\homework-with-router\\node_modules\\redux-devtools-instrument\\src\\instrument.ts"],"sourcesContent":["import difference from 'lodash/difference';\nimport union from 'lodash/union';\nimport isPlainObject from 'lodash/isPlainObject';\nimport $$observable from 'symbol-observable';\nimport {\n  Action,\n  Observable,\n  PreloadedState,\n  Reducer,\n  Store,\n  StoreEnhancer,\n  StoreEnhancerStoreCreator,\n} from 'redux';\n\nexport const ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING',\n} as const;\n\nconst isChrome =\n  typeof window === 'object' &&\n  (typeof (window as typeof window & { chrome: unknown }).chrome !==\n    'undefined' ||\n    (typeof window.process !== 'undefined' &&\n      (window.process as typeof window.process & { type: unknown }).type ===\n        'renderer'));\n\nconst isChromeOrNode =\n  isChrome ||\n  (typeof process !== 'undefined' &&\n    process.release &&\n    process.release.name === 'node');\n\nexport interface PerformAction<A extends Action<unknown>> {\n  type: typeof ActionTypes.PERFORM_ACTION;\n  action: A;\n  timestamp: number;\n  stack: string | undefined;\n}\n\ninterface ResetAction {\n  type: typeof ActionTypes.RESET;\n  timestamp: number;\n}\n\ninterface RollbackAction {\n  type: typeof ActionTypes.ROLLBACK;\n  timestamp: number;\n}\n\ninterface CommitAction {\n  type: typeof ActionTypes.COMMIT;\n  timestamp: number;\n}\n\ninterface SweepAction {\n  type: typeof ActionTypes.SWEEP;\n}\n\ninterface ToggleAction {\n  type: typeof ActionTypes.TOGGLE_ACTION;\n  id: number;\n}\n\ninterface SetActionsActiveAction {\n  type: typeof ActionTypes.SET_ACTIONS_ACTIVE;\n  start: number;\n  end: number;\n  active: boolean;\n}\n\ninterface ReorderAction {\n  type: typeof ActionTypes.REORDER_ACTION;\n  actionId: number;\n  beforeActionId: number;\n}\n\ninterface JumpToStateAction {\n  type: typeof ActionTypes.JUMP_TO_STATE;\n  index: number;\n}\n\ninterface JumpToActionAction {\n  type: typeof ActionTypes.JUMP_TO_ACTION;\n  actionId: number;\n}\n\ninterface ImportStateAction<S, A extends Action<unknown>, MonitorState> {\n  type: typeof ActionTypes.IMPORT_STATE;\n  nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[];\n  preloadedState?: S;\n  noRecompute: boolean | undefined;\n}\n\ninterface LockChangesAction {\n  type: typeof ActionTypes.LOCK_CHANGES;\n  status: boolean;\n}\n\ninterface PauseRecordingAction {\n  type: typeof ActionTypes.PAUSE_RECORDING;\n  status: boolean;\n}\n\nexport type LiftedAction<S, A extends Action<unknown>, MonitorState> =\n  | PerformAction<A>\n  | ResetAction\n  | RollbackAction\n  | CommitAction\n  | SweepAction\n  | ToggleAction\n  | SetActionsActiveAction\n  | ReorderAction\n  | JumpToStateAction\n  | JumpToActionAction\n  | ImportStateAction<S, A, MonitorState>\n  | LockChangesAction\n  | PauseRecordingAction;\n\n/**\n * Action creators to change the History state.\n */\nexport const ActionCreators = {\n  performAction<A extends Action<unknown>>(\n    action: A,\n    trace?: ((action: A) => string | undefined) | boolean,\n    traceLimit?: number,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    toExcludeFromTrace?: Function\n  ) {\n    if (!isPlainObject(action)) {\n      throw new Error(\n        'Actions must be plain objects. ' +\n          'Use custom middleware for async actions.'\n      );\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      );\n    }\n\n    let stack;\n    if (trace) {\n      let extraFrames = 0;\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        const error = Error();\n        let prevStackTraceLimit;\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (traceLimit && Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n        if (\n          extraFrames ||\n          typeof Error.stackTraceLimit !== 'number' ||\n          (traceLimit && Error.stackTraceLimit > traceLimit)\n        ) {\n          if (stack != null) {\n            const frames = stack.split('\\n');\n            if (traceLimit && frames.length > traceLimit) {\n              stack = frames\n                .slice(\n                  0,\n                  traceLimit +\n                    extraFrames +\n                    (frames[0].startsWith('Error') ? 1 : 0)\n                )\n                .join('\\n');\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action,\n      timestamp: Date.now(),\n      stack,\n    };\n  },\n\n  reset(): ResetAction {\n    return { type: ActionTypes.RESET, timestamp: Date.now() };\n  },\n\n  rollback(): RollbackAction {\n    return { type: ActionTypes.ROLLBACK, timestamp: Date.now() };\n  },\n\n  commit(): CommitAction {\n    return { type: ActionTypes.COMMIT, timestamp: Date.now() };\n  },\n\n  sweep(): SweepAction {\n    return { type: ActionTypes.SWEEP };\n  },\n\n  toggleAction(id: number): ToggleAction {\n    return { type: ActionTypes.TOGGLE_ACTION, id };\n  },\n\n  setActionsActive(\n    start: number,\n    end: number,\n    active = true\n  ): SetActionsActiveAction {\n    return { type: ActionTypes.SET_ACTIONS_ACTIVE, start, end, active };\n  },\n\n  reorderAction(actionId: number, beforeActionId: number): ReorderAction {\n    return { type: ActionTypes.REORDER_ACTION, actionId, beforeActionId };\n  },\n\n  jumpToState(index: number): JumpToStateAction {\n    return { type: ActionTypes.JUMP_TO_STATE, index };\n  },\n\n  jumpToAction(actionId: number): JumpToActionAction {\n    return { type: ActionTypes.JUMP_TO_ACTION, actionId };\n  },\n\n  importState<S, A extends Action<unknown>, MonitorState = null>(\n    nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[],\n    noRecompute?: boolean\n  ): ImportStateAction<S, A, MonitorState> {\n    return { type: ActionTypes.IMPORT_STATE, nextLiftedState, noRecompute };\n  },\n\n  lockChanges(status: boolean): LockChangesAction {\n    return { type: ActionTypes.LOCK_CHANGES, status };\n  },\n\n  pauseRecording(status: boolean): PauseRecordingAction {\n    return { type: ActionTypes.PAUSE_RECORDING, status };\n  },\n};\n\nexport const INIT_ACTION = { type: '@@INIT' };\n\n/**\n * Computes the next entry with exceptions catching.\n */\nfunction computeWithTryCatch<S, A extends Action<unknown>>(\n  reducer: Reducer<S, A>,\n  action: A,\n  state: S\n) {\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(() => {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError,\n  };\n}\n\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry<S, A extends Action<unknown>>(\n  reducer: Reducer<S, A>,\n  action: A,\n  state: S,\n  shouldCatchErrors: boolean | undefined\n) {\n  if (!shouldCatchErrors) {\n    return { state: reducer(state, action) };\n  }\n  return computeWithTryCatch(reducer, action, state);\n}\n\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates<S, A extends Action<unknown>>(\n  computedStates: { state: S; error?: string }[],\n  minInvalidatedStateIndex: number,\n  reducer: Reducer<S, A>,\n  committedState: S,\n  actionsById: { [actionId: number]: PerformAction<A> },\n  stagedActionIds: number[],\n  skippedActionIds: number[],\n  shouldCatchErrors: boolean | undefined\n) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (\n    !computedStates ||\n    minInvalidatedStateIndex === -1 ||\n    (minInvalidatedStateIndex >= computedStates.length &&\n      computedStates.length === stagedActionIds.length)\n  ) {\n    return computedStates;\n  }\n\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    let entry;\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain',\n        };\n      } else {\n        entry = computeNextEntry(\n          reducer,\n          action,\n          previousState,\n          shouldCatchErrors\n        );\n      }\n    }\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nexport function liftAction<A extends Action<unknown>>(\n  action: A,\n  trace?: ((action: A) => string | undefined) | boolean,\n  traceLimit?: number,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  toExcludeFromTrace?: Function\n) {\n  return ActionCreators.performAction(\n    action,\n    trace,\n    traceLimit,\n    toExcludeFromTrace\n  );\n}\n\nfunction isArray<S, A extends Action<unknown>, MonitorState>(\n  nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[]\n): nextLiftedState is readonly A[] {\n  return Array.isArray(nextLiftedState);\n}\n\nexport interface LiftedState<S, A extends Action<unknown>, MonitorState> {\n  monitorState: MonitorState;\n  nextActionId: number;\n  actionsById: { [actionId: number]: PerformAction<A> };\n  stagedActionIds: number[];\n  skippedActionIds: number[];\n  committedState: S;\n  currentStateIndex: number;\n  computedStates: { state: S; error?: string }[];\n  isLocked: boolean;\n  isPaused: boolean;\n}\n\n/**\n * Creates a history state reducer from an app's reducer.\n */\nexport function liftReducerWith<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  MonitorAction extends Action<unknown>\n>(\n  reducer: Reducer<S, A>,\n  initialCommittedState: PreloadedState<S> | undefined,\n  monitorReducer: Reducer<MonitorState, MonitorAction>,\n  options: Options<S, A, MonitorState, MonitorAction>\n): Reducer<LiftedState<S, A, MonitorState>, LiftedAction<S, A, MonitorState>> {\n  const initialLiftedState: LiftedState<S, A, MonitorState> = {\n    monitorState: monitorReducer(undefined, {} as MonitorAction),\n    nextActionId: 1,\n    actionsById: { 0: liftAction(INIT_ACTION as A) },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState as S,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false,\n  };\n\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (\n    liftedState: LiftedState<S, A, MonitorState> | undefined,\n    liftedAction: LiftedAction<S, A, MonitorState>\n  ): LiftedState<S, A, MonitorState> => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    } = liftedState || initialLiftedState;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = { ...actionsById };\n    }\n\n    function commitExcessActions(n: number) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(\n        (id) => idsToDelete.indexOf(id) === -1\n      );\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex =\n        currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function computePausedAction(\n      shouldInit?: boolean\n    ): LiftedState<S, A, MonitorState> {\n      let computedState;\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(\n          monitorState,\n          liftedAction as MonitorAction\n        );\n      } else {\n        computedState = computeNextEntry(\n          reducer,\n          (liftedAction as PerformAction<A>).action,\n          computedStates[currentStateIndex].state,\n          false\n        );\n      }\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState,\n          actionsById: { 0: liftAction(INIT_ACTION as A) },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked,\n          isPaused: true,\n        };\n      }\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        stagedActionIds = [...stagedActionIds, nextActionId];\n        nextActionId++;\n      }\n      return {\n        monitorState,\n        actionsById: {\n          ...actionsById,\n          [nextActionId - 1]: liftAction({\n            type: options.pauseActionType,\n          } as A),\n        },\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates: [\n          ...computedStates.slice(0, stagedActionIds.length - 1),\n          computedState,\n        ],\n        isLocked,\n        isPaused: true,\n      };\n    }\n\n    // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n\n    // maxAge number can be changed dynamically\n    let maxAge = options.maxAge;\n    if (typeof maxAge === 'function')\n      maxAge = maxAge(liftedAction, liftedState);\n\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = { 0: liftAction(INIT_ACTION as A) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState =\n          computedStates.length === 0\n            ? (initialCommittedState as S)\n            : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      }\n\n      // Recompute states on hot reload and init.\n      minInvalidatedStateIndex = 0;\n\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates<S, A>(\n          computedStates,\n          minInvalidatedStateIndex,\n          reducer,\n          committedState,\n          actionsById,\n          stagedActionIds,\n          skippedActionIds,\n          options.shouldCatchErrors\n        );\n\n        commitExcessActions(stagedActionIds.length - maxAge);\n\n        // Avoid double computation.\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION: {\n          if (isLocked) return liftedState || initialLiftedState;\n          if (isPaused) return computePausedAction();\n\n          // Auto-commit as new actions come in.\n          if (maxAge && stagedActionIds.length >= maxAge) {\n            commitExcessActions(stagedActionIds.length - maxAge + 1);\n          }\n\n          if (currentStateIndex === stagedActionIds.length - 1) {\n            currentStateIndex++;\n          }\n          const actionId = nextActionId++;\n          // Mutation! This is the hottest path, and we optimize on purpose.\n          // It is safe because we set a new key in a cache dictionary.\n          actionsById[actionId] = liftedAction;\n          stagedActionIds = [...stagedActionIds, actionId];\n          // Optimization: we know that only the new action needs computing.\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          break;\n        }\n        case ActionTypes.RESET: {\n          // Get back to the state the store was created with.\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = initialCommittedState as S;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case ActionTypes.COMMIT: {\n          // Consider the last committed state the new starting point.\n          // Squash any staged actions into a single committed state.\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = computedStates[currentStateIndex].state;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case ActionTypes.ROLLBACK: {\n          // Forget about any staged actions.\n          // Start again from the last committed state.\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case ActionTypes.TOGGLE_ACTION: {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const { id: actionId } = liftedAction;\n          const index = skippedActionIds.indexOf(actionId);\n          if (index === -1) {\n            skippedActionIds = [actionId, ...skippedActionIds];\n          } else {\n            skippedActionIds = skippedActionIds.filter((id) => id !== actionId);\n          }\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n          break;\n        }\n        case ActionTypes.SET_ACTIONS_ACTIVE: {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const { start, end, active } = liftedAction;\n          const actionIds = [];\n          for (let i = start; i < end; i++) actionIds.push(i);\n          if (active) {\n            skippedActionIds = difference(skippedActionIds, actionIds);\n          } else {\n            skippedActionIds = union(skippedActionIds, actionIds);\n          }\n\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n          break;\n        }\n        case ActionTypes.JUMP_TO_STATE: {\n          // Without recomputing anything, move the pointer that tell us\n          // which state is considered the current one. Useful for sliders.\n          currentStateIndex = liftedAction.index;\n          // Optimization: we know the history has not changed.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case ActionTypes.JUMP_TO_ACTION: {\n          // Jumps to a corresponding state to a specific action.\n          // Useful when filtering actions.\n          const index = stagedActionIds.indexOf(liftedAction.actionId);\n          if (index !== -1) currentStateIndex = index;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case ActionTypes.SWEEP: {\n          // Forget any actions that are currently being skipped.\n          stagedActionIds = difference(stagedActionIds, skippedActionIds);\n          skippedActionIds = [];\n          currentStateIndex = Math.min(\n            currentStateIndex,\n            stagedActionIds.length - 1\n          );\n          break;\n        }\n        case ActionTypes.REORDER_ACTION: {\n          // Recompute actions in a new order.\n          const actionId = liftedAction.actionId;\n          const idx = stagedActionIds.indexOf(actionId);\n          // do nothing in case the action is already removed or trying to move the first action\n          if (idx < 1) break;\n          const beforeActionId = liftedAction.beforeActionId;\n          let newIdx = stagedActionIds.indexOf(beforeActionId);\n          if (newIdx < 1) {\n            // move to the beginning or to the end\n            const count = stagedActionIds.length;\n            newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n          }\n          const diff = idx - newIdx;\n\n          if (diff > 0) {\n            // move left\n            stagedActionIds = [\n              ...stagedActionIds.slice(0, newIdx),\n              actionId,\n              ...stagedActionIds.slice(newIdx, idx),\n              ...stagedActionIds.slice(idx + 1),\n            ];\n            minInvalidatedStateIndex = newIdx;\n          } else if (diff < 0) {\n            // move right\n            stagedActionIds = [\n              ...stagedActionIds.slice(0, idx),\n              ...stagedActionIds.slice(idx + 1, newIdx),\n              actionId,\n              ...stagedActionIds.slice(newIdx),\n            ];\n            minInvalidatedStateIndex = idx;\n          }\n          break;\n        }\n        case ActionTypes.IMPORT_STATE: {\n          if (isArray(liftedAction.nextLiftedState)) {\n            // recompute array of actions\n            actionsById = { 0: liftAction(INIT_ACTION as A) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = liftedAction.nextLiftedState.length;\n            computedStates = [];\n            committedState = liftedAction.preloadedState as S;\n            minInvalidatedStateIndex = 0;\n            // iterate through actions\n            liftedAction.nextLiftedState.forEach((action) => {\n              actionsById[nextActionId] = liftAction(\n                action,\n                options.trace || options.shouldIncludeCallstack\n              );\n              stagedActionIds.push(nextActionId);\n              nextActionId++;\n            });\n          } else {\n            // Completely replace everything.\n            ({\n              monitorState,\n              actionsById,\n              nextActionId,\n              stagedActionIds,\n              skippedActionIds,\n              committedState,\n              currentStateIndex,\n              computedStates,\n            } = liftedAction.nextLiftedState);\n\n            if (liftedAction.noRecompute) {\n              minInvalidatedStateIndex = Infinity;\n            }\n          }\n\n          break;\n        }\n        case ActionTypes.LOCK_CHANGES: {\n          isLocked = liftedAction.status;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case ActionTypes.PAUSE_RECORDING: {\n          isPaused = liftedAction.status;\n          if (isPaused) {\n            return computePausedAction(true);\n          }\n          // Commit when unpausing\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = computedStates[currentStateIndex].state;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        default: {\n          // If the action is not recognized, it's a monitor action.\n          // Optimization: a monitor action can't change history.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      }\n    }\n\n    computedStates = recomputeStates(\n      computedStates,\n      minInvalidatedStateIndex,\n      reducer,\n      committedState,\n      actionsById,\n      stagedActionIds,\n      skippedActionIds,\n      options.shouldCatchErrors\n    );\n    monitorState = monitorReducer(monitorState, liftedAction as MonitorAction);\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    };\n  };\n}\n\n/**\n * Provides an app's view into the state of the lifted store.\n */\nexport function unliftState<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  NextStateExt\n>(\n  liftedState: LiftedState<S, A, MonitorState> & NextStateExt\n): S & NextStateExt {\n  const { computedStates, currentStateIndex } = liftedState;\n  const { state } = computedStates[currentStateIndex];\n  return state as S & NextStateExt;\n}\n\nexport type LiftedReducer<S, A extends Action<unknown>, MonitorState> = Reducer<\n  LiftedState<S, A, MonitorState>,\n  LiftedAction<S, A, MonitorState>\n>;\n\nexport type LiftedStore<S, A extends Action<unknown>, MonitorState> = Store<\n  LiftedState<S, A, MonitorState>,\n  LiftedAction<S, A, MonitorState>\n>;\n\nexport type InstrumentExt<S, A extends Action<unknown>, MonitorState> = {\n  liftedStore: LiftedStore<S, A, MonitorState>;\n};\n\nexport type EnhancedStore<S, A extends Action<unknown>, MonitorState> = Store<\n  S,\n  A\n> &\n  InstrumentExt<S, A, MonitorState>;\n\n/**\n * Provides an app's view into the lifted store.\n */\nexport function unliftStore<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  MonitorAction extends Action<unknown>,\n  NextExt,\n  NextStateExt\n>(\n  liftedStore: Store<\n    LiftedState<S, A, MonitorState> & NextStateExt,\n    LiftedAction<S, A, MonitorState>\n  > &\n    NextExt,\n  liftReducer: (r: Reducer<S, A>) => LiftedReducer<S, A, MonitorState>,\n  options: Options<S, A, MonitorState, MonitorAction>\n) {\n  let lastDefinedState: S & NextStateExt;\n  const trace = options.trace || options.shouldIncludeCallstack;\n  const traceLimit = options.traceLimit || 10;\n\n  function getState(): S & NextStateExt {\n    const state = unliftState<S, A, MonitorState, NextStateExt>(\n      liftedStore.getState()\n    );\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n    return lastDefinedState;\n  }\n\n  function dispatch<T extends A>(action: T): T {\n    liftedStore.dispatch(liftAction<A>(action, trace, traceLimit, dispatch));\n    return action;\n  }\n\n  return ({\n    ...liftedStore,\n\n    liftedStore,\n\n    dispatch,\n\n    getState,\n\n    replaceReducer(nextReducer: Reducer<S & NextStateExt, A>) {\n      liftedStore.replaceReducer(\n        (liftReducer(\n          (nextReducer as unknown) as Reducer<S, A>\n        ) as unknown) as Reducer<\n          LiftedState<S, A, MonitorState> & NextStateExt,\n          LiftedAction<S, A, MonitorState>\n        >\n      );\n    },\n\n    [$$observable](): Observable<S> {\n      return {\n        ...(liftedStore as any)[$$observable](),\n        subscribe(observer) {\n          if (typeof observer !== 'object') {\n            throw new TypeError('Expected the observer to be an object.');\n          }\n\n          function observeState() {\n            if (observer.next) {\n              observer.next(getState());\n            }\n          }\n\n          observeState();\n          const unsubscribe = liftedStore.subscribe(observeState);\n          return { unsubscribe };\n        },\n\n        [$$observable]() {\n          return this;\n        },\n      };\n    },\n  } as unknown) as Store<S & NextStateExt, A> &\n    NextExt & {\n      liftedStore: Store<\n        LiftedState<S, A, MonitorState> & NextStateExt,\n        LiftedAction<S, A, MonitorState>\n      >;\n    };\n}\n\nexport interface Options<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  MonitorAction extends Action<unknown>\n> {\n  maxAge?:\n    | number\n    | ((\n        currentLiftedAction: LiftedAction<S, A, MonitorState>,\n        previousLiftedState: LiftedState<S, A, MonitorState> | undefined\n      ) => number);\n  shouldCatchErrors?: boolean;\n  shouldRecordChanges?: boolean;\n  pauseActionType?: unknown;\n  shouldStartLocked?: boolean;\n  shouldHotReload?: boolean;\n  trace?: boolean | ((action: A) => string | undefined);\n  traceLimit?: number;\n  shouldIncludeCallstack?: boolean;\n}\n\n/**\n * Redux instrumentation store enhancer.\n */\nexport default function instrument<\n  OptionsS,\n  OptionsA extends Action<unknown>,\n  MonitorState = null,\n  MonitorAction extends Action<unknown> = never\n>(\n  monitorReducer: Reducer<MonitorState, MonitorAction> = ((() =>\n    null) as unknown) as Reducer<MonitorState, MonitorAction>,\n  options: Options<OptionsS, OptionsA, MonitorState, MonitorAction> = {}\n): StoreEnhancer<InstrumentExt<any, any, MonitorState>> {\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error(\n      'DevTools.instrument({ maxAge }) option, if specified, ' +\n        'may not be less than 2.'\n    );\n  }\n\n  return <NextExt, NextStateExt>(\n    createStore: StoreEnhancerStoreCreator<NextExt, NextStateExt>\n  ) => <S, A extends Action<unknown>>(\n    reducer: Reducer<S, A>,\n    initialState?: PreloadedState<S>\n  ) => {\n    function liftReducer(r: Reducer<S, A>) {\n      if (typeof r !== 'function') {\n        if (r && typeof (r as { default: unknown }).default === 'function') {\n          throw new Error(\n            'Expected the reducer to be a function. ' +\n              'Instead got an object with a \"default\" field. ' +\n              'Did you pass a module instead of the default export? ' +\n              'Try passing require(...).default instead.'\n          );\n        }\n        throw new Error('Expected the reducer to be a function.');\n      }\n      return liftReducerWith<S, A, MonitorState, MonitorAction>(\n        r,\n        initialState,\n        monitorReducer,\n        (options as unknown) as Options<S, A, MonitorState, MonitorAction>\n      );\n    }\n\n    const liftedStore = createStore(liftReducer(reducer));\n    if (\n      (liftedStore as Store<\n        LiftedState<S, A, MonitorState> & NextStateExt,\n        LiftedAction<S, A, MonitorState>\n      > &\n        NextExt & {\n          liftedStore: Store<\n            LiftedState<S, A, MonitorState>,\n            LiftedAction<S, A, MonitorState>\n          >;\n        }).liftedStore\n    ) {\n      throw new Error(\n        'DevTools instrumentation should not be applied more than once. ' +\n          'Check your store configuration.'\n      );\n    }\n\n    return unliftStore<\n      S,\n      A,\n      MonitorState,\n      MonitorAction,\n      NextExt,\n      NextStateExt\n    >(\n      liftedStore,\n      liftReducer,\n      (options as unknown) as Options<S, A, MonitorState, MonitorAction>\n    );\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}